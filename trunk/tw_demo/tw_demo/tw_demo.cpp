/*
-----------------------------------------------------------------------------
Filename:    tw_demo.cpp
-----------------------------------------------------------------------------

This source file is generated by the Ogre AppWizard.

Check out: http://conglomerate.berlios.de/wiki/doku.php?id=ogrewizards

Based on the Example Framework for OGRE
(Object-oriented Graphics Rendering Engine)

Copyright (c) 2000-2007 The OGRE Team
For the latest info, see http://www.ogre3d.org/

You may use this sample code for anything you like, it is not covered by the
LGPL like the rest of the OGRE engine.
-----------------------------------------------------------------------------
*/

#include "tw_demo.h"
#include <sstream>
using namespace std;
#include "Line3D.h"
template<> tw_demoApp* Ogre::Singleton<tw_demoApp>::ms_Singleton = 0;
//-------------------------------------------------------------------------------------
tw_demoApp::tw_demoApp(void)
{
	m_npoints = 0;
	mpRayQuery = 0;
}
//-------------------------------------------------------------------------------------
tw_demoApp::~tw_demoApp(void)
{

}

//-------------------------------------------------------------------------------------
void tw_demoApp::createScene(void)
{
	// setup GUI system
	mGUIRenderer = new CEGUI::OgreCEGUIRenderer(mWindow,
		Ogre::RENDER_QUEUE_OVERLAY, false, 3000, mSceneMgr);

	mGUISystem = new CEGUI::System(mGUIRenderer);

	CEGUI::Logger::getSingleton().setLoggingLevel(CEGUI::Informative);

	EnumThreadWindows( GetCurrentThreadId(), tw_demoApp::EnumThreadWndProc,(LPARAM)&m_hwnd);
	mpfnWndProc =(WNDPROC) SetWindowLongPtr(m_hwnd,GWLP_WNDPROC,(LONG)tw_demoApp::wndProc);

	ShowCursor(FALSE);
	SetCapture(m_hwnd);
	RECT rcClip;
	GetWindowRect(m_hwnd, &rcClip); 
	ClipCursor(&rcClip); 


	// load scheme and set up defaults
	CEGUI::SchemeManager::getSingleton().loadScheme(
		(CEGUI::utf8*)"TaharezLookSkin.scheme");
	mGUISystem->setDefaultFont((CEGUI::utf8*)"BlueHighway-12");
	setupEventHandlers();

	m_MultiMice = new MultiMouse(mWindow->getWidth(),mWindow->getHeight());
	m_MultiMice->CaptureDevices(m_hwnd);

	CreateImages();

	// Set ambient light
	mSceneMgr->setAmbientLight(ColourValue(0.5, 0.5, 0.5));

	// Create a light
	Light* l = mSceneMgr->createLight("MainLight");
	l->setPosition(20,80,50);
}

void tw_demoApp::CreateImages()
{

	int i=0;
	ostringstream sout;
	sout<<"pic"<<i;
	MovablePlane* plane = new MovablePlane(sout.str());
	plane->normal = Vector3::UNIT_Z;
	MeshPtr planeMesh = MeshManager::getSingleton().createPlane(sout.str(),ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		*plane,
		10.0f,10.0f);

	MaterialPtr material = MaterialManager::getSingleton().create(sout.str().c_str(), "General");
	material->getTechnique(0)->getPass(0)->createTextureUnitState("tw.jpg");
	Entity* entity = mSceneMgr->createEntity(sout.str(),sout.str());
	entity->setMaterialName(sout.str());	
	SceneNode* sn = mSceneMgr->getRootSceneNode()->createChildSceneNode(sout.str().c_str());
	sn->showBoundingBox(true);
	sn->attachObject(entity);
	m_TouchableNodes[sout.str()] = new TouchableNode(sn);
}

void tw_demoApp::loadResources()
{
	LPSTR path = GetCommandLine();
	String str = path;
	int index = str.find_last_of("\"") + 2;

	ResourceGroupManager::getSingleton().addResourceLocation(path+ index,"FileSystem");
	BaseApplication::loadResources();
}



void tw_demoApp::DebugPoint(Vector3 pos,SceneNode* parentSn,float scale)
{
	static int num = 0;
	ostringstream sout;
	sout<<"debugPT"<<num;
	Entity* en = mSceneMgr->createEntity(sout.str(),SceneManager::PrefabType::PT_CUBE);
	SceneNode *sn =parentSn->createChildSceneNode(pos);
	sn->attachObject(en);
	sn->setScale(scale,scale,scale);
	num++;
}

SceneNode* tw_demoApp::CastRay( float tx,float ty, Vector3& intersection_point )
{
	MovableObject* mCurrMO = 0; 
	// calc the ray using normalised screen coordinates [0-1]
	Ray ray = mCamera->getCameraToViewportRay(tx,ty);

	// Set up the ray query
	if (!mpRayQuery)
		mpRayQuery = mSceneMgr->createRayQuery(ray);
	else
		mpRayQuery->setRay(ray); // update ray
	// Sort by distance, and say we're only interested in the first hit
	mpRayQuery->setSortByDistance(true, 1);
	// Execute

	RaySceneQueryResult res = mpRayQuery->execute();
	RaySceneQueryResult::iterator it = res.begin();
	if (it != res.end())
	{
		mCurrMO = it->movable;
		mDebugText += "   - " +mCurrMO->getName();
		intersection_point = ray.getPoint(it->distance);
		//DebugPoint(intersection_point);
		mpRayQuery->clearResults();
		return mCurrMO->getParentSceneNode();
	}
	else
	{
		mCurrMO = NULL;
		mpRayQuery->clearResults();
		return NULL;
	}
}

bool tw_demoApp::frameStarted( const FrameEvent& evt )
{
	HashMap<string, TouchableNode*>::iterator it;
	for (it = m_TouchableNodes.begin(); it != m_TouchableNodes.end(); it++)
	{
		it->second->Update();
	}

	return BaseApplication::frameStarted(evt);
}


LRESULT tw_demoApp::wndProc( HWND hwnd,UINT msg, WPARAM wparam,LPARAM lparam )
{
	if(msg == WM_INPUT)
	{
		tw_demoApp::getSingleton().m_MultiMice->HandleInput(hwnd,msg,wparam,lparam);
	}
	else if (msg == WM_SETFOCUS || msg == WM_ACTIVATE || msg == WM_ACTIVATEAPP)
	{
		ShowCursor(FALSE);
		SetCapture(hwnd);
		RECT rcClip;
		GetWindowRect(hwnd, &rcClip); 
		ClipCursor(&rcClip); 
	}

	return tw_demoApp::getSingleton().mpfnWndProc(hwnd,msg,wparam,lparam);
}

BOOL CALLBACK tw_demoApp::EnumThreadWndProc( HWND hwnd,LPARAM lParam )
{
	HWND * ptr_hwnd = (HWND*)lParam;
	*ptr_hwnd= hwnd;
	return FALSE;

}

void tw_demoApp::MultiMouseMoved( Mouse& state)
{
	if(state.isLButtonDown && state.m_selectedObject)
	{
		float dx = (float)state.xPos / (float)state.cxScreen;
		float dy = (float)state.yPos / (float)state.cyScreen;
		Ray ray = mCamera->getCameraToViewportRay(dx,dy);
		Plane plane(Vector3::UNIT_Z,0);

		pair<bool,Real> result =  ray.intersects(plane);
		if(result.first)		//intersects .. 
		{
			Vector3 newPos = ray.getPoint(result.second);
			state.m_selectedObject->MoveControlPoint(state.m_position_index,newPos);
		}
	}
}

void tw_demoApp::MultiMouseLPressed( Mouse& state)
{
	float dx = (float)state.xPos / (float)state.cxScreen;
	float dy = (float)state.yPos / (float)state.cyScreen;
	ostringstream sout;
	sout<<dx<<" "<<dy;
	mDebugText = sout.str();
	Vector3 pos;
	SceneNode* sn = CastRay(dx,dy,pos);
	if(sn)
	{
		state.m_selectedObject = m_TouchableNodes[sn->getName()];
		if(state.m_selectedObject)
			state.m_position_index = state.m_selectedObject->AddControlPoint(pos);
	}
}

void tw_demoApp::MultiMouseLReleased( Mouse& state)
{
	if(state.m_selectedObject)
	{
		state.m_selectedObject->RemoveControlPoint(state.m_position_index);
		if(state.m_selectedObject->m_old_positions.size() == 0 && state.m_selectedObject->m_positions.size() )
			state.m_selectedObject= NULL;
	}
}
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
extern "C" {
	INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
	{
		tw_demoApp app;
		//	try {
		app.go();
		//	} catch( Ogre::Exception& e ) {
		//		MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
		//	}
		return 0;
	}
}


void TouchableNode::Update()
{
	if(! isChanged)
		return;
	if(m_old_positions.size() > 1)
	{
		//get current state 
		Vector3 new_max_scale(FLT_MIN,FLT_MIN,0);
		Vector3 new_min_scale(FLT_MAX,FLT_MAX,0);
		Vector3 new_center(Vector3::ZERO);
		vector<Vector3>::iterator it;
		//get the center
		for (it = m_positions.begin();it != m_positions.end(); it++)
		{
			new_max_scale.x = max(new_max_scale.x , it->x);
			new_max_scale.y = max(new_max_scale.y , it->y);

			new_min_scale.x = min(new_min_scale.x , it->x);
			new_min_scale.y = min(new_min_scale.y , it->y);

			new_center += *it;
		}
		new_center /= (float)m_positions.size();

		//get old state 
		Vector3 old_max_scale(FLT_MIN,FLT_MIN,0);
		Vector3 old_min_scale(FLT_MAX,FLT_MAX,0);
		Vector3 old_center(Vector3::ZERO);
		//get the center
		for (it = m_old_positions.begin();it != m_old_positions.end(); it++)
		{
			old_max_scale.x = max(old_max_scale.x , it->x);
			old_max_scale.y = max(old_max_scale.y , it->y);

			old_min_scale.x = min(old_min_scale.x , it->x);
			old_min_scale.y = min(old_min_scale.y , it->y);

			old_center += *it;
		}
		old_center /= (float)m_old_positions.size();

		//compare between both states
		
		//----------translate
		m_SceneNode->translate(new_center - old_center);
		
		//----------scale
		//compare state scales
		Vector3 new_scale = new_max_scale - new_min_scale;
		Vector3 old_scale = old_max_scale - old_min_scale;
		float sx = abs(new_scale.x / old_scale.x);
		float sy = abs(new_scale.y / old_scale.y);
		//add it to the original scalling of the object
		Vector3 current_scale = m_SceneNode->getScale();
		current_scale.x *= sx;
		current_scale.y *= sy;
		//keep minimum size allowed .. its a picture after all
		current_scale.x = max(0.00001f, current_scale.x );
		current_scale.y = max(0.00001f, current_scale.y );
		//commit
		m_SceneNode->setScale(current_scale);

		//-------Rotate
		//compare rotate states
		Vector3 new_dir = m_positions[0] - new_center;
		Vector3 old_dir = m_old_positions[0] - old_center;
		Quaternion q1 = Vector3::UNIT_X.getRotationTo(old_dir);
		Quaternion q2 = Vector3::UNIT_X.getRotationTo(new_dir);
		q2 = q2 - q1;
		//add to original rotation
		Quaternion q = m_SceneNode->getOrientation();
		q = q + q2;
		//commit
		m_SceneNode->setOrientation(q);

		tw_demoApp::getSingleton().mDebugText = StringConverter::toString(old_center) + " \r\n" + StringConverter::toString(new_center);
	}
	
	//update positions
	m_old_positions.clear();
	if(m_positions.size() > 0)
	{
		insert_iterator<vector<Vector3>> insIt(m_old_positions,m_old_positions.begin());
		copy(m_positions.begin(),m_positions.end(),insIt);
	}

}


TouchableNode::TouchableNode( SceneNode* sn)
{
	m_SceneNode = sn;
	isChanged = false;
}
int TouchableNode::AddControlPoint(Vector3& pos)
{
	isChanged = true;
	m_positions.push_back(pos);
	return m_positions.size()-1;
}

void TouchableNode::RemoveControlPoint( int at )
{
	if(m_positions.size() > at )
		m_positions.erase( m_positions.begin() + at );
	if(m_old_positions.size() > at)
		m_old_positions.erase( m_old_positions.begin() + at );

}

void TouchableNode::MoveControlPoint( int at ,Vector3& new_pos)
{
	isChanged = true;
	if(m_positions.size() > at)
		m_positions[at] = new_pos;
}