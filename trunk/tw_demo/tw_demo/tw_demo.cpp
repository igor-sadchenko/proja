/*
-----------------------------------------------------------------------------
Filename:    tw_demo.cpp
-----------------------------------------------------------------------------

This source file is generated by the Ogre AppWizard.

Check out: http://conglomerate.berlios.de/wiki/doku.php?id=ogrewizards

Based on the Example Framework for OGRE
(Object-oriented Graphics Rendering Engine)

Copyright (c) 2000-2007 The OGRE Team
For the latest info, see http://www.ogre3d.org/

You may use this sample code for anything you like, it is not covered by the
LGPL like the rest of the OGRE engine.
-----------------------------------------------------------------------------
*/

#include "tw_demo.h"
#include <sstream>
using namespace std;
#include "Line3D.h"
#include "TouchableNode.h"
template<> tw_demoApp* Ogre::Singleton<tw_demoApp>::ms_Singleton = 0;
//-------------------------------------------------------------------------------------
tw_demoApp::tw_demoApp(void)
{
	m_npoints = 0;
	mpRayQuery = 0;
}
//-------------------------------------------------------------------------------------
tw_demoApp::~tw_demoApp(void)
{

}

//-------------------------------------------------------------------------------------
void tw_demoApp::createScene(void)
{
	// setup GUI system
	mGUIRenderer = new CEGUI::OgreCEGUIRenderer(mWindow,
		Ogre::RENDER_QUEUE_OVERLAY, false, 3000, mSceneMgr);

	mGUISystem = new CEGUI::System(mGUIRenderer);

	CEGUI::Logger::getSingleton().setLoggingLevel(CEGUI::Informative);

	EnumThreadWindows( GetCurrentThreadId(), tw_demoApp::EnumThreadWndProc,(LPARAM)&m_hwnd);
	mpfnWndProc =(WNDPROC) SetWindowLongPtr(m_hwnd,GWLP_WNDPROC,(LONG)tw_demoApp::wndProc);

	ShowCursor(FALSE);
	SetCapture(m_hwnd);
	RECT rcClip;
	GetWindowRect(m_hwnd, &rcClip); 
	ClipCursor(&rcClip); 


	// load scheme and set up defaults
	CEGUI::SchemeManager::getSingleton().loadScheme(
		(CEGUI::utf8*)"TaharezLookSkin.scheme");
	mGUISystem->setDefaultFont((CEGUI::utf8*)"BlueHighway-12");
	setupEventHandlers();

	m_MultiMice = new MultiMouse(mWindow->getWidth(),mWindow->getHeight());
	m_MultiMice->CaptureDevices(m_hwnd);

	CreateImages();

	// Set ambient light
	mSceneMgr->setAmbientLight(ColourValue(0.5, 0.5, 0.5));

	// Create a light
	Light* l = mSceneMgr->createLight("MainLight");
	l->setPosition(20,80,50);
}

void tw_demoApp::CreateImages()
{

	int i=0;
	ostringstream sout;
	sout<<"pic"<<i;
	MovablePlane* plane = new MovablePlane(sout.str());
	plane->normal = Vector3::UNIT_Z;
	MeshPtr planeMesh = MeshManager::getSingleton().createPlane(sout.str(),ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		*plane,
		10.0f,10.0f);

	MaterialPtr material = MaterialManager::getSingleton().create(sout.str().c_str(), "General");
	material->getTechnique(0)->getPass(0)->createTextureUnitState("tw.jpg");
	Entity* entity = mSceneMgr->createEntity(sout.str(),sout.str());
	entity->setMaterialName(sout.str());	
	SceneNode* sn = mSceneMgr->getRootSceneNode()->createChildSceneNode(sout.str().c_str());
	sn->showBoundingBox(true);
	sn->attachObject(entity);
	m_TouchableNodes[sout.str()] = new TouchableNode(sn);
}

void tw_demoApp::loadResources()
{
	LPSTR path = GetCommandLine();
	String str = path;
	int index = str.find_last_of("\"") + 2;

	ResourceGroupManager::getSingleton().addResourceLocation(path+ index,"FileSystem");
	BaseApplication::loadResources();
}



void tw_demoApp::DebugPoint(Vector3 pos,SceneNode* parentSn,float scale)
{
	static int num = 0;
	ostringstream sout;
	sout<<"debugPT"<<num;
	Entity* en = mSceneMgr->createEntity(sout.str(),SceneManager::PrefabType::PT_CUBE);
	SceneNode *sn =parentSn->createChildSceneNode(pos);
	sn->attachObject(en);
	sn->setScale(scale,scale,scale);
	num++;
}

SceneNode* tw_demoApp::CastRay( float tx,float ty, Vector3& intersection_point )
{
	MovableObject* mCurrMO = 0; 
	// calc the ray using normalised screen coordinates [0-1]
	Ray ray = mCamera->getCameraToViewportRay(tx,ty);

	// Set up the ray query
	if (!mpRayQuery)
		mpRayQuery = mSceneMgr->createRayQuery(ray);
	else
		mpRayQuery->setRay(ray); // update ray
	// Sort by distance, and say we're only interested in the first hit
	mpRayQuery->setSortByDistance(true, 1);
	// Execute

	RaySceneQueryResult res = mpRayQuery->execute();
	RaySceneQueryResult::iterator it = res.begin();
	if (it != res.end())
	{
		mCurrMO = it->movable;
		mDebugText += "   - " +mCurrMO->getName();
		intersection_point = ray.getPoint(it->distance);
		//DebugPoint(intersection_point);
		mpRayQuery->clearResults();
		return mCurrMO->getParentSceneNode();
	}
	else
	{
		mCurrMO = NULL;
		mpRayQuery->clearResults();
		return NULL;
	}
}

bool tw_demoApp::frameStarted( const FrameEvent& evt )
{
	HashMap<string, TouchableNode*>::iterator it;
	for (it = m_TouchableNodes.begin(); it != m_TouchableNodes.end(); it++)
	{
		it->second->Update();
	}

	return BaseApplication::frameStarted(evt);
}


LRESULT tw_demoApp::wndProc( HWND hwnd,UINT msg, WPARAM wparam,LPARAM lparam )
{
	if(msg == WM_INPUT)
	{
		tw_demoApp::getSingleton().m_MultiMice->HandleInput(hwnd,msg,wparam,lparam);
	}
	else if (msg == WM_SETFOCUS || msg == WM_ACTIVATE || msg == WM_ACTIVATEAPP)
	{
		ShowCursor(FALSE);
		SetCapture(hwnd);
		RECT rcClip;
		GetWindowRect(hwnd, &rcClip); 
		ClipCursor(&rcClip); 
	}

	return tw_demoApp::getSingleton().mpfnWndProc(hwnd,msg,wparam,lparam);
}

BOOL CALLBACK tw_demoApp::EnumThreadWndProc( HWND hwnd,LPARAM lParam )
{
	HWND * ptr_hwnd = (HWND*)lParam;
	*ptr_hwnd= hwnd;
	return FALSE;

}

void tw_demoApp::MultiMouseMoved( Mouse& state)
{
	if(state.isLButtonDown && state.m_selectedObject)
	{
		float dx = (float)state.xPos / (float)state.cxScreen;
		float dy = (float)state.yPos / (float)state.cyScreen;
		Ray ray = mCamera->getCameraToViewportRay(dx,dy);
		Plane plane(Vector3::UNIT_Z,0);

		pair<bool,Real> result =  ray.intersects(plane);
		if(result.first)		//intersects .. 
		{
			Vector3 newPos = ray.getPoint(result.second);
			state.m_selectedObject->MoveControlPoint(state.m_position_index,newPos);
		}
	}
}

void tw_demoApp::MultiMouseLPressed( Mouse& state)
{
	float dx = (float)state.xPos / (float)state.cxScreen;
	float dy = (float)state.yPos / (float)state.cyScreen;
	ostringstream sout;
	sout<<dx<<" "<<dy;
	mDebugText = sout.str();
	Vector3 pos;
	SceneNode* sn = CastRay(dx,dy,pos);
	if(sn)
	{
		state.m_selectedObject = m_TouchableNodes[sn->getName()];
		if(state.m_selectedObject)
			state.m_position_index = state.m_selectedObject->AddControlPoint(pos);
	}
}

void tw_demoApp::MultiMouseLReleased( Mouse& state)
{
	if(state.m_selectedObject)
	{
		state.m_selectedObject->RemoveControlPoint(state.m_position_index);
		if(state.m_selectedObject->m_old_positions.size() == 0 && state.m_selectedObject->m_positions.size() )
			state.m_selectedObject= NULL;
	}
}
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
extern "C" {
	INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
	{
		tw_demoApp app;
		//	try {
		app.go();
		//	} catch( Ogre::Exception& e ) {
		//		MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
		//	}
		return 0;
	}
}


